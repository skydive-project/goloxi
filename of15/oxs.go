/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of15

import (
	"encoding/json"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type Oxs struct {
	TypeLen uint32
}

type IOxs interface {
	goloxi.Serializable
	GetTypeLen() uint32
	GetOXSName() string
	GetOXSValue() interface{}
}

func (self *Oxs) GetTypeLen() uint32 {
	return self.TypeLen
}

func (self *Oxs) SetTypeLen(v uint32) {
	self.TypeLen = v
}

func (self *Oxs) Serialize(encoder *goloxi.Encoder) error {

	encoder.PutUint32(uint32(self.TypeLen))

	return nil
}

func DecodeOxs(decoder *goloxi.Decoder) (IOxs, error) {
	_oxs := &Oxs{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Oxs packet too short: %d < 4", decoder.Length())
	}
	_oxs.TypeLen = uint32(decoder.ReadUint32())

	switch _oxs.TypeLen {
	case 2147616776:
		return DecodeOxsByteCount(_oxs, decoder)
	case 2147614728:
		return DecodeOxsDuration(_oxs, decoder)
	case 2147615748:
		return DecodeOxsFlowCount(_oxs, decoder)
	case 2147616264:
		return DecodeOxsPacketCount(_oxs, decoder)
	case 2147615240:
		return DecodeOxsIdleTime(_oxs, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Oxs'", _oxs.TypeLen)
	}
}

func NewOxs(_type_len uint32) *Oxs {
	obj := &Oxs{}
	obj.TypeLen = _type_len
	return obj
}

type OxsByteCount struct {
	*Oxs
	Value uint64
}

type IOxsByteCount interface {
	IOxs
	GetValue() uint64
}

func (self *OxsByteCount) GetValue() uint64 {
	return self.Value
}

func (self *OxsByteCount) SetValue(v uint64) {
	self.Value = v
}

func (self *OxsByteCount) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Oxs.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeOxsByteCount(parent *Oxs, decoder *goloxi.Decoder) (*OxsByteCount, error) {
	_oxsbytecount := &OxsByteCount{Oxs: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("OxsByteCount packet too short: %d < 8", decoder.Length())
	}
	_oxsbytecount.Value = uint64(decoder.ReadUint64())
	return _oxsbytecount, nil
}

func NewOxsByteCount() *OxsByteCount {
	obj := &OxsByteCount{
		Oxs: NewOxs(2147616776),
	}
	return obj
}
func (self *OxsByteCount) GetOXSName() string {
	return "byte_count"
}

func (self *OxsByteCount) GetOXSValue() interface{} {
	return self.Value
}

func (self *OxsByteCount) MarshalJSON() ([]byte, error) {
	var value interface{} = self.GetOXSValue()
	switch t := value.(type) {
	case net.HardwareAddr:
		value = t.String()
	case net.IP:
		value = t.String()
	default:
		if s, ok := t.(fmt.Stringer); ok {
			value = s.String()
		} else {
			value = t
		}
	}

	jsonValue, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("{\"Type\":\"%s\",\"Value\":%s}", self.GetOXSName(), string(jsonValue))), nil
}

type OxsDuration struct {
	*Oxs
	Value uint64
}

type IOxsDuration interface {
	IOxs
	GetValue() uint64
}

func (self *OxsDuration) GetValue() uint64 {
	return self.Value
}

func (self *OxsDuration) SetValue(v uint64) {
	self.Value = v
}

func (self *OxsDuration) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Oxs.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeOxsDuration(parent *Oxs, decoder *goloxi.Decoder) (*OxsDuration, error) {
	_oxsduration := &OxsDuration{Oxs: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("OxsDuration packet too short: %d < 8", decoder.Length())
	}
	_oxsduration.Value = uint64(decoder.ReadUint64())
	return _oxsduration, nil
}

func NewOxsDuration() *OxsDuration {
	obj := &OxsDuration{
		Oxs: NewOxs(2147614728),
	}
	return obj
}
func (self *OxsDuration) GetOXSName() string {
	return "duration"
}

func (self *OxsDuration) GetOXSValue() interface{} {
	return self.Value
}

func (self *OxsDuration) MarshalJSON() ([]byte, error) {
	var value interface{} = self.GetOXSValue()
	switch t := value.(type) {
	case net.HardwareAddr:
		value = t.String()
	case net.IP:
		value = t.String()
	default:
		if s, ok := t.(fmt.Stringer); ok {
			value = s.String()
		} else {
			value = t
		}
	}

	jsonValue, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("{\"Type\":\"%s\",\"Value\":%s}", self.GetOXSName(), string(jsonValue))), nil
}

type OxsFlowCount struct {
	*Oxs
	Value uint32
}

type IOxsFlowCount interface {
	IOxs
	GetValue() uint32
}

func (self *OxsFlowCount) GetValue() uint32 {
	return self.Value
}

func (self *OxsFlowCount) SetValue(v uint32) {
	self.Value = v
}

func (self *OxsFlowCount) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Oxs.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	return nil
}

func DecodeOxsFlowCount(parent *Oxs, decoder *goloxi.Decoder) (*OxsFlowCount, error) {
	_oxsflowcount := &OxsFlowCount{Oxs: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("OxsFlowCount packet too short: %d < 4", decoder.Length())
	}
	_oxsflowcount.Value = uint32(decoder.ReadUint32())
	return _oxsflowcount, nil
}

func NewOxsFlowCount() *OxsFlowCount {
	obj := &OxsFlowCount{
		Oxs: NewOxs(2147615748),
	}
	return obj
}
func (self *OxsFlowCount) GetOXSName() string {
	return "flow_count"
}

func (self *OxsFlowCount) GetOXSValue() interface{} {
	return self.Value
}

func (self *OxsFlowCount) MarshalJSON() ([]byte, error) {
	var value interface{} = self.GetOXSValue()
	switch t := value.(type) {
	case net.HardwareAddr:
		value = t.String()
	case net.IP:
		value = t.String()
	default:
		if s, ok := t.(fmt.Stringer); ok {
			value = s.String()
		} else {
			value = t
		}
	}

	jsonValue, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("{\"Type\":\"%s\",\"Value\":%s}", self.GetOXSName(), string(jsonValue))), nil
}

type OxsIdleTime struct {
	*Oxs
	Value uint64
}

type IOxsIdleTime interface {
	IOxs
	GetValue() uint64
}

func (self *OxsIdleTime) GetValue() uint64 {
	return self.Value
}

func (self *OxsIdleTime) SetValue(v uint64) {
	self.Value = v
}

func (self *OxsIdleTime) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Oxs.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeOxsIdleTime(parent *Oxs, decoder *goloxi.Decoder) (*OxsIdleTime, error) {
	_oxsidletime := &OxsIdleTime{Oxs: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("OxsIdleTime packet too short: %d < 8", decoder.Length())
	}
	_oxsidletime.Value = uint64(decoder.ReadUint64())
	return _oxsidletime, nil
}

func NewOxsIdleTime() *OxsIdleTime {
	obj := &OxsIdleTime{
		Oxs: NewOxs(2147615240),
	}
	return obj
}
func (self *OxsIdleTime) GetOXSName() string {
	return "idle_time"
}

func (self *OxsIdleTime) GetOXSValue() interface{} {
	return self.Value
}

func (self *OxsIdleTime) MarshalJSON() ([]byte, error) {
	var value interface{} = self.GetOXSValue()
	switch t := value.(type) {
	case net.HardwareAddr:
		value = t.String()
	case net.IP:
		value = t.String()
	default:
		if s, ok := t.(fmt.Stringer); ok {
			value = s.String()
		} else {
			value = t
		}
	}

	jsonValue, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("{\"Type\":\"%s\",\"Value\":%s}", self.GetOXSName(), string(jsonValue))), nil
}

type OxsPacketCount struct {
	*Oxs
	Value uint64
}

type IOxsPacketCount interface {
	IOxs
	GetValue() uint64
}

func (self *OxsPacketCount) GetValue() uint64 {
	return self.Value
}

func (self *OxsPacketCount) SetValue(v uint64) {
	self.Value = v
}

func (self *OxsPacketCount) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Oxs.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeOxsPacketCount(parent *Oxs, decoder *goloxi.Decoder) (*OxsPacketCount, error) {
	_oxspacketcount := &OxsPacketCount{Oxs: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("OxsPacketCount packet too short: %d < 8", decoder.Length())
	}
	_oxspacketcount.Value = uint64(decoder.ReadUint64())
	return _oxspacketcount, nil
}

func NewOxsPacketCount() *OxsPacketCount {
	obj := &OxsPacketCount{
		Oxs: NewOxs(2147616264),
	}
	return obj
}
func (self *OxsPacketCount) GetOXSName() string {
	return "packet_count"
}

func (self *OxsPacketCount) GetOXSValue() interface{} {
	return self.Value
}

func (self *OxsPacketCount) MarshalJSON() ([]byte, error) {
	var value interface{} = self.GetOXSValue()
	switch t := value.(type) {
	case net.HardwareAddr:
		value = t.String()
	case net.IP:
		value = t.String()
	default:
		if s, ok := t.(fmt.Stringer); ok {
			value = s.String()
		} else {
			value = t
		}
	}

	jsonValue, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("{\"Type\":\"%s\",\"Value\":%s}", self.GetOXSName(), string(jsonValue))), nil
}
